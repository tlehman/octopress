---
layout: post
title: "Visualization of SICP Exercise 1.14"
date: 2013-04-07 18:17
comments: true
categories: [dataviz, sicp, lisp, scheme, programming]
---

I am currently working my way the [Structure and Interpretation of
Computer Programs](https://github.com/tlehman/sicp-exercises#readme)
and I've skipped past exercise 1.14, and come back to it after a bit
of thinking, here's the problem, and then the exercise.

*The Problem*: How many ways are there to make change of a given
 `amount` with the following kinds of coins?

 - pennies
 - nickels
 - dimes 
 - quarters
 - half-dollars

There is a recursive solution to this combinatorial problem, which can
readily be made into executable code in Scheme, this kind of solution
is very standard in enumerative combinatorics:

The number of ways to change amount `a` using `n` kinds of coins
equals:

 - the number of ways to change amount `a` using all but the first
 kind of coin, plus
 - the number of ways to change amount `a - d` using all but the
 first kind of coins, where `d` is the denomination of the first kind
 of coin

Note that those two items are mutually exclusive and exhaustive
conditions, so the result can be calculated by simply adding the two
values.

In scheme, the above list could be transliterated as:

```scheme
	(+ (cc a (- n 1))
	   (cc (- a d) n))
```

Where `cc` computes the number of ways of changing amount `a` with `n`
number of coins.

The full code for the `count-change` procedure can be found 
[here](https://github.com/tlehman/sicp-exercises/blob/master/count-change.scm#L3).

With the `count-change` procedure at hand, Exercise 1.14 is to "draw
the tree illustrating the process generated by the `count-change`
procedure in making change for 11 cents."

*The Solution*: 

The `count-change` procedure uses the `(cc a n)` procedure where
`n = 5`, and the `cc` procedure naturally gives rise to a binary
tree that locally looks like this:

{% img /images/blogimg/ccan.png %}

I prefer to make the computer go through all the steps and produce an
image for me, so I took a break on 1.14 and thought about it for a
while.

To represent the tree, I used the [graph-description language
[DOT](http://en.wikipedia.org/wiki/DOT_(graph_description_language))

To generate the tree, I started by adding a print statement around the
recursion steps, the problem with that is that there can be distinct
nodes that happen to have the same argument values, that is, the node
in the tree may be labeled `(cc a n)`, but there may also be multiple
nodes with the same `a` and `n` values. To avoid this, each node must
be given a unique id, and then be displayed with the `(cc a n)` label.

One way to label a binary tree's nodes is to make the id be a map of
the location of the node in the tree. For example, if a node of the
tree has id `x`, then the root's children will be `xl` and `xr`,
respectively, where `l` stands for 'left' and `r` stands for 'right'.

The full source of this tree-generating code `cc-graph` can be found 
[here](https://github.com/tlehman/sicp-exercises/blob/master/count-change.scm#L29). 

Finally, the output of running `(cc-graph 11 5)`, then piping the
results into GraphViz gives the desired tree: 

{% img /images/blogimg/cc_11_5.png %}

The final value of `(cc 11 5)` is 4, that is there are 4 ways of
making change for 11 cents. Unfortunately, this solution doesn't say
what exact combinations of coins, only that there are four.

There are more than 100 edges in that tree, I would not have wanted to
do that by hand, all for a measley value of four.

I would like to generalize `cc-graph` so that I can get a
visualization of any recursive function in scheme, this will take more
knowledge of the language and it's introspective features, stay tuned!
