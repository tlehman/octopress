---
layout: post
title: "Visualization of SICP Exercise 1.14"
date: 2013-04-07 18:17
comments: true
categories: [dataviz, sicp, lisp, scheme, programming]
---

I am currently working my way the [Structure and Interpretation of
Computer Programs](https://github.com/tlehman/sicp-exercises#readme)
and I've skipped past exercise 1.14, and come back to it after a bit
of thinking, here's the problem, and then the exercise.

*The Problem*: How many ways are there to make change of a given
 `amount` with the following kinds of coins?

 - pennies
 - nickels
 - dimes 
 - quarters
 - half-dollars

There is a recursive solution to this combinatorial problem, which can
readily be made into executable code in Scheme, this kind of solution
is very standard in enumerative combinatorics:

The number of ways to change amount `a` using `n` kinds of coins
equals:

 - the number of ways to change amount `a` using all but the first
 kind of coin, plus
 - the number of ways to change amount `a - d` using all but the
 first kind of coins, where `d` is the denomination of the first kind
 of coin

Note that those two items are mutually exclusive and exhaustive
conditions, so the result can be calculated by simply adding the two
values.

In scheme, the above list could be transliterated as:

```scheme
	(+ (cc a (- n 1))
	   (cc (- a d) n))
```

Where `cc` computes the number of ways of changing amount `a` with `n`
number of coins.

The full code for the `count-change` procedure can be found 
[here](https://github.com/tlehman/sicp-exercises/blob/master/count-change.scm#L3).

With the `count-change` procedure at hand, Exercise 1.14 is to "draw
the tree illustrating the process generated by the `count-change`
procedure in making change for 11 cents."

The `count-change` procedure uses the `(cc a n)` procedure where
`n = 5`, and the `cc` procedure naturually gives rise to a binary
tree that locally looks like this:

{% img /images/blogimg/ccan.png %}

I prefer to make the computer go through all the steps and produce an
image for me, so I took a break on 1.14 and thought about it for a
while.

To represent the tree, I used the [graph-description language DOT](http://en.wikipedia.org/wiki/DOT_(graph_description_language))